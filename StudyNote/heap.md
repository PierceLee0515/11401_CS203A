# Heap (堆積)

---

## 1. 關於 Heap (核心概念)

* ### 什麼是 Heap (What's Heap)?
    - 它是一種 **完全二元樹 (Complete Binary Tree)**，且必須符合 **堆積順序性質 (Heap-Order property)**。


* ### 完全二元樹 (結構特性):
    - 除了最後一層外，所有層的節點都是滿的。
    - 節點必須**由左至右**依序插入，中間不能有空隙。

* ### 什麼是 Heap-Order (排序特性)?
    - **定義**: 指的不是插入的先後順序，而是父節點與子節點之間必須永遠維持的 **大小關係規則**。
    - **最大堆積 (Max-heap)**: 根節點永遠是最大值。每個父節點都大於或等於其子節點。
      $$Parent\ Nodes \ge Child\ Nodes$$
    - **最小堆積 (Min-heap)**: 根節點永遠是最小值。每個父節點都小於或等於其子節點。
      $$Parent\ Nodes \le Child\ Nodes$$

---

## 2. Max-heap & Min-heap (實作與屬性)

* ### Max-heap (最大堆積)
    - **特性**:
        1. 最頂端的節點是所有節點中的最大值。
        2. 任意父節點的值都大於其子節點。
    

* ### Min-heap (最小堆積)
    - **特性**:
        1. 最頂端的節點是所有節點中的最小值。
        2. 任意父節點的值都小於其子節點。
    

* ### 陣列實作 (Implement By Array):
    - 由於完全二元樹的結構確保了節點之間沒有空隙，使用陣列儲存非常高效。
    - **索引公式 (若從索引 0 開始)**:
        - 父節點索引: `(i - 1) / 2`
        - 左子節點索引: `2 * i + 1`
        - 右子節點索引: `2 * i + 2`

---

## 3. ADT / 時間複雜度 (Time-Complexity)

| 操作 (Operation) | 描述 (Description) | 時間複雜度 |
| :--- | :--- | :--- |
| **Access** | 透過索引存取 | $O(1)$ |
| **Search** | 搜尋任意值 | $O(N)$ |
| **Insertion** | 新增元素並恢復堆積性質 | $O(\log N)$ |
| **Deletion** | 刪除節點並恢復堆積性質 | $O(\log N)$ |
| **Extract_root** | 取出並移除根節點 (最大/最小) | $O(\log N)$ |
| **Peek_root** | 查看根節點的值 | $O(1)$ |
| **Build_heap** | 將一般陣列轉換成堆積 | $O(N)$ |
| **Heapify** | 在特定節點恢復堆積性質 | $O(\log N)$ |

* **Insertion 解釋**:
    因為樹的高度為 $\log N$，當新節點插入最底層後，向上調整 (Bubble Up) 最多只需經過高度次比較。
* **Extract_root 解釋**:
    為了不破壞「完全二元樹」的結構，我們會將**最後一個節點**移到根位置，再向下調整 (Heapify Down)。
* **Build_heap 為什麼是 $O(N)$?**
    雖然單次 Heapify 是 $O(\log N)$，但 Build_heap 是從倒數第二層開始向上處理。大部分節點位在底層（高度低，調整快），只有少數節點位在頂層。經過數學級數求和證明，總複雜度收斂於 $O(N)$ 而非 $O(N \log N)$。

---

## 4. 應用 (Application)

1. **排程 (Scheduling)**：處理有優先順序的任務。
2. **優先權佇列 (Priority Queue)**：永遠只取出最優先（最大或最小）的任務執行。
3. **Heap Sort (堆積排序)**：利用堆積結構進行的高效排序演算法。

---

## 5. 註記 (Notes)

* **視覺化理解**：堆積的操作（如插入與刪除）建議配合動畫觀察「交換 (Swap)」的過程，能更直觀地理解如何維持 Heap-Order。
* **空間效率**：與平衡二元搜尋樹 (如 AVL) 不同，Heap 不需要額外儲存平衡因子，且用陣列即可實作，記憶體開銷較小。
